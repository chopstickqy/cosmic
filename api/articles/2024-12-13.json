{"title":"Sentry Micro-FE solution","uid":"909ee2240a74e34caa640d66f6578279","slug":"2024-12-13","date":"2024-12-12T16:00:00.000Z","updated":"2025-02-15T17:52:03.176Z","comments":true,"path":"api/articles/2024-12-13.json","keywords":null,"cover":null,"content":"<h2 id=\"前景介绍\"><a href=\"#前景介绍\" class=\"headerlink\" title=\"前景介绍\"></a>前景介绍</h2><p>项目在迭代过程中，公共逻辑或组件的重复使用频率也在逐渐增加。为了方便管理公共组件代码，提升开发效率等，在项目中引入微前端或者微组件的概念。</p>\n<p>当前项目的 source map 通过 Jenkins 部署代码时同步上传到 Sentry 进行管理，因此，其他 gems 或 sweets 组件无法通过相同方式上传 source map。因此，需要新的方案来解决微前端项目的 source map 上传问题。</p>\n<h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>Sentry 官网提供了微前端方案：<a href=\"https://docs.sentry.io/platforms/javascript/guides/deno/best-practices/micro-frontends/\">Sentry Micro-Frontends</a>。</p>\n<h3 id=\"功能代码修改：\"><a href=\"#功能代码修改：\" class=\"headerlink\" title=\"功能代码修改：\"></a>功能代码修改：</h3><ul>\n<li>引入 <strong>Sentry Plugin - moduleMetadata 模块</strong>，对编译后的文件增加元数据。</li>\n<li>Sentry 初始化时引入 <strong>metadataIntegrations</strong> 处理元数据。</li>\n<li>通过元数据 <strong>多路传输</strong>。</li>\n</ul>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"Sentry-Plugin-Metadata-Module\"><a href=\"#Sentry-Plugin-Metadata-Module\" class=\"headerlink\" title=\"Sentry Plugin - Metadata Module\"></a><a href=\"https://github.com/search?q=repo:getsentry/sentry-javascript-bundler-plugins%20webpackModuleMetadataInjectionPlugin&type=code\">Sentry Plugin - Metadata Module</a></h3><ul>\n<li>该插件通过 Webpack 内置的 <code>BannerPlugin</code> 在编译后的文件头部注入元数据。</li>\n<li>元数据会注入到 <code>window.sentryModuleMetadata</code> 对象下，<code>[key]</code> 为当前文件的 URL (<code>new window.Error().stack</code>)，<code>[value]</code> 为元数据值。</li>\n</ul>\n<h3 id=\"moduleMetadataIntegration\"><a href=\"#moduleMetadataIntegration\" class=\"headerlink\" title=\"moduleMetadataIntegration\"></a><a href=\"https://github.com/getsentry/sentry-javascript/blob/13bb652e068693eaad920467133f19cde46b0a85/packages/core/src/integrations/metadata.ts#L16\">moduleMetadataIntegration</a></h3><ul>\n<li>通过 <code>beforeEnvelope</code> 生命周期拦截发送到 Sentry 的数据包，从事件的堆栈帧（stack frames）中剥离元数据（metadata），确保数据仅在客户端处理，不会发送到 Sentry 服务器，减少传输的数据量并保护隐私。</li>\n<li>通过 <code>applyFrameMetadata</code> 生命周期，将元数据注入到当前事件中。</li>\n</ul>\n<h3 id=\"多路传输-makeMultiplexedTransport\"><a href=\"#多路传输-makeMultiplexedTransport\" class=\"headerlink\" title=\"多路传输 makeMultiplexedTransport\"></a>多路传输 <code>makeMultiplexedTransport</code></h3><ul>\n<li><code>beforeSend</code> 增加解析元数据逻辑，并注入到事件中。</li>\n<li>注册多路传输 <code>transport</code>，根据解析出的元数据分发请求。</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>元数据中必须的参数 <code>dsn</code> 和 <code>release</code><ul>\n<li><code>dsn</code>：用于请求发送到指定仓库。</li>\n<li><code>release</code>：用于版本匹配映射到具体的 source map。<ul>\n<li>使用 <code>DefinePlugin</code> 将打包的镜像版本设置为全局变量：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.<span class=\"title class_\">DefinePlugin</span>(&#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;process.env.RELEASE_TAG&#x27;</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(release)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":"前景介绍项目在迭代过程中，公共逻辑或组件的重复使用频率也在逐渐增加。为了方便管理公共组件代码，提升开发效率等，在项目中引入微前端或者微组件的概念。 当前项目的 ...","permalink":"/post/2024-12-13","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"Technology","slug":"Technology","count":1,"path":"api/categories/Technology.json"}],"tags":[{"name":"Micro-FE","slug":"Micro-FE","count":1,"path":"api/tags/Micro-FE.json"},{"name":"Sentry","slug":"Sentry","count":1,"path":"api/tags/Sentry.json"},{"name":"Frontend","slug":"Frontend","count":1,"path":"api/tags/Frontend.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E6%99%AF%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">前景介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%EF%BC%9A\"><span class=\"toc-text\">功能代码修改：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Sentry-Plugin-Metadata-Module\"><span class=\"toc-text\">Sentry Plugin - Metadata Module</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#moduleMetadataIntegration\"><span class=\"toc-text\">moduleMetadataIntegration</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E8%B7%AF%E4%BC%A0%E8%BE%93-makeMultiplexedTransport\"><span class=\"toc-text\">多路传输 makeMultiplexedTransport</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">其他</span></a></li></ol>","author":{"name":"Charles","slug":"blog-author","avatar":"https://chopstickqy.github.io/images/logo.png","link":"/","description":"Think like an artist, develop like an artisan.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Mac 软件推荐","uid":"1b162f21a9a3e02dbe9fc7a5fa2ed998","slug":"2025-01-01","date":"2025-01-01T16:00:00.000Z","updated":"2025-02-15T17:52:03.176Z","comments":true,"path":"api/articles/2025-01-01.json","keywords":null,"cover":null,"text":"1. oh my zsh - 终端的美学与效率革命12# 一键安装命令sh -c \"$(curl -fsSL https://raw.github.com/oh...","permalink":"/post/2025-01-01","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"效率工具","slug":"效率工具","count":1,"path":"api/categories/效率工具.json"}],"tags":[{"name":"Mac","slug":"Mac","count":1,"path":"api/tags/Mac.json"},{"name":"软件推荐","slug":"软件推荐","count":1,"path":"api/tags/软件推荐.json"}],"author":{"name":"Charles","slug":"blog-author","avatar":"https://chopstickqy.github.io/images/logo.png","link":"/","description":"Think like an artist, develop like an artisan.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"解决 node-canvas 安装问题：Mac M1、Python 版本、musl 兼容性","uid":"d81abd1fab3fac8213cc029b31d1d3c6","slug":"2024-11-26","date":"2024-11-25T16:00:00.000Z","updated":"2025-02-15T17:52:03.176Z","comments":true,"path":"api/articles/2024-11-26.json","keywords":null,"cover":null,"text":"背景在项目中需要生成二维码，因此选择了 easyqrcodejs 作为前端和后端（Node.js）二维码生成方案。然而，在服务端使用 easyqrcodejs ...","permalink":"/post/2024-11-26","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"技术","slug":"技术","count":3,"path":"api/categories/技术.json"}],"tags":[{"name":"node-canvas","slug":"node-canvas","count":1,"path":"api/tags/node-canvas.json"},{"name":"EasyQRCodeJS","slug":"EasyQRCodeJS","count":1,"path":"api/tags/EasyQRCodeJS.json"},{"name":"Node.js","slug":"Node-js","count":1,"path":"api/tags/Node-js.json"},{"name":"M1","slug":"M1","count":1,"path":"api/tags/M1.json"},{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"author":{"name":"Charles","slug":"blog-author","avatar":"https://chopstickqy.github.io/images/logo.png","link":"/","description":"Think like an artist, develop like an artisan.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}