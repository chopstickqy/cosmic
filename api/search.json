[{"id":"c5839525a12cd4a2c139c1c5acb5cb1e","title":"ISSUE & FEATURE COLLECTION","content":"1 - issue: 解决访问github SSL_ERROR_SYSCALL问题12$ git pushfatal: unable to access &#x27;https://github.com/gentleen/token-back-end.git/&#x27;: OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443\n\npush 代码的时候产生如上错误\n1git config --global http.sslBackend &quot;openssl&quot;\n\n执行如上命令 解决\n2 - issue: 解决AngualrJS不能设置Content-Type请求头问题如 transformRequest 示例\n1234567891011121314151617$http(&#123;    method: &#x27;GET&#x27;,    url: &#x27;rest/home/banners&#x27;,    headers: &#123;        &quot;x-version&quot;: &quot;h5-v1.0.0&quot;,        &quot;x-timestamp&quot;: currentdate,        &#x27;Content-type&#x27;: &#x27;application/json&#x27;      &#125;,    transformRequest:function(obj)&#123;        var str=[];        for(var p in obj)&#123;            str.push(encodeURIComponent(p) + &quot;-&quot;+encodeURIComponent(obj[p]));        &#125;        return str.join(&quot;&amp;&quot;);    &#125;    ... ...&#125;);\n\n3 - feature: Angular button throttle directive sample1234567891011121314151617181920212223242526272829303132import &#123; Directive, EventEmitter, HostListener, OnInit, Output &#125; from &#x27;@angular/core&#x27;;import &#123; Subject, Subscription &#125; from &#x27;rxjs&#x27;;import &#123; throttleTime &#125; from &#x27;rxjs/operators&#x27;;@Directive(&#123;  selector: &#x27;[throttleClickDirective]&#x27;&#125;)export class ThrottleClickDirective implements OnInit &#123;    @Output() throttleClick = new EventEmitter();    private clicks = new Subject();    private subscription: Subscription;    constructor() &#123; &#125;    ngOnInit() &#123;      this.subscription = this.clicks.pipe(          throttleTime(1000)      ).subscribe(e =&gt; this.throttleClick.emit(e));    &#125;    ngOnDestroy() &#123;      this.subscription.unsubscribe();    &#125;    @HostListener(&#x27;click&#x27;, [&#x27;$event&#x27;])    clickEvent(event) &#123;      event.preventDefault();      event.stopPropagation();      this.clicks.next(event);    &#125;&#125;\n\n4 - issue: Running docker container : iptables: No chain&#x2F;target&#x2F;match by that name1iptables -t filter -F\n1iptables -t filter -X\n\n\nwhich indeeds clear all chains. One possible solution is to launch the docker daemon after the iptables setup script. Otherwise you will need to explicitly removes chains you’re interested in.\n\nThen restart docker\n\n\n1systemctl restart docker\n","slug":"collection","date":"2025-02-15T17:52:03.176Z","categories_index":"","tags_index":"","author_index":"Charles"},{"id":"1b162f21a9a3e02dbe9fc7a5fa2ed998","title":"Mac 软件推荐","content":"1. oh my zsh - 终端的美学与效率革命12# 一键安装命令sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;\n\n\n✨ 主题画廊：200+ 主题瞬间美化终端界面\n⚡ 智能补全：输入命令时按 Tab 自动提示\n🔌 插件生态：\ngit：显示分支状态和文件修改标识\nzsh-autosuggestions：基于历史记录预测命令\nsyntax-highlighting：命令行语法高亮\n\n\n\n2. tmux - 终端多任务管理1brew install tmux  # 通过 Homebrew 安装\n\n\n🖥️ 分屏工作流：Ctrl+b % 垂直分屏 &#x2F; Ctrl+b &quot; 水平分屏\n💾 会话持久化：SSH 断开后保持进程运行（用 tmux attach 恢复）\n🎮 快捷键体系：\nCtrl+b d 分离会话\nCtrl+b [ 进入滚动模式\nCtrl+b z 放大当前面板\n\n\n\n更多快捷键参考tmux 快捷键合集\n3. hammerspoon - 系统自动化神器Hammerspoon 是一款基于 Lua 脚本的 macOS 自动化工具，功能强大且高度可定制，最主要的，完完完完完全开源免费，相比于Alfred仅此一点就可以无脑冲了。这里给出我在安装使用时参考的B站博主视频视频内，博主也给出了他自己写的一个lua脚本，没有luacoding基础的小伙伴可以先拿来直接用\n4. Obsidian：构建你的第二大脑在信息爆炸的时代，如何高效地管理知识成为了每个人的挑战。Obsidian，这款以“第二大脑”为理念的笔记工具，正逐渐成为知识工作者的得力助手。\n技术优势\n代码友好型知识图谱  \n\n支持 [[双向链接]] + #标签 + Mermaid图表 三维关联系统\n可视化呈现技术概念间的调用关系（如微服务架构拓扑）\n通过 Dataview 插件实现类数据库查询：  1LIST WHERE contains(tags, &quot;#API设计&quot;) AND file.ctime &gt; date(2023-01-01)\n\n\n工程化扩展能力\n\n插件系统基于 TypeScript 开发，支持自定义工作流：\n集成 Terminal 实现 CLI 操作\n通过 REST API 连接 Jira&#x2F;Jenkins\n开发代码片段自动收集插件\n\n\nCSS 主题定制 + 热重载调试，媲美 IDE 的个性化体验\n\n\nGit 原生工作流\n\n纯 Markdown 存储天然适配版本控制\n自动 commit 插件实现文档 CI&#x2F;CD：1234# .obsidian/git-auto-commit.shgit add .git commit -m &quot;Auto-save: $(date)&quot;git push origin main\n完美支持 GitHub Pages 文档同步发布\n\n\n\n开发者应用场景▌ 技术文档中枢\n\n用 Admonition 插件创建标准化的 API 说明模板\n通过 Excalidraw 绘制系统架构图并嵌入文档\n使用 CodeMirror 实现 IDE 级代码高亮\n\n▌ 学习攻坚利器  \n\n建立 算法题解/设计模式/源码分析 的网状知识库\n用 Latex Suite 高效编写技术公式：123\\begin&#123;align*&#125;O(n\\log n) &amp; \\text&#123; 时间复杂度 &#125; \\\\\\end&#123;align*&#125;\n\n▌ 研发过程管理\n\nKanban 看板跟踪 Sprint 任务\nTemplater 自动生成 RFC 技术提案模板\n通过 Daily Notes 实现 standup meeting 记录\n\n▌ 个人代码库\n\n构建可搜索的代码片段库：123456789# 快速排序 @Algorithmsdef quick_sort(arr):    if len(arr) &lt;= 1:        return arr    pivot = arr[len(arr) // 2]    left = [x for x in arr if x &lt; pivot]    middle = [x for x in arr if x == pivot]    right = [x for x in arr if x &gt; pivot]    return quick_sort(left) + middle + quick_sort(right)\n\n进阶技巧\n使用 VSCode-Obsidian 插件实现双编辑器联动\n通过 Obsidian Git 实现多设备同步\n开发自定义插件对接内部 DevOps 平台\n\n","slug":"2025-01-01","date":"2025-01-01T16:00:00.000Z","categories_index":"效率工具","tags_index":"Mac,软件推荐","author_index":"Charles"},{"id":"909ee2240a74e34caa640d66f6578279","title":"Sentry Micro-FE solution","content":"前景介绍项目在迭代过程中，公共逻辑或组件的重复使用频率也在逐渐增加。为了方便管理公共组件代码，提升开发效率等，在项目中引入微前端或者微组件的概念。\n当前项目的 source map 通过 Jenkins 部署代码时同步上传到 Sentry 进行管理，因此，其他 gems 或 sweets 组件无法通过相同方式上传 source map。因此，需要新的方案来解决微前端项目的 source map 上传问题。\n方案Sentry 官网提供了微前端方案：Sentry Micro-Frontends。\n功能代码修改：\n引入 Sentry Plugin - moduleMetadata 模块，对编译后的文件增加元数据。\nSentry 初始化时引入 metadataIntegrations 处理元数据。\n通过元数据 多路传输。\n\n代码实现Sentry Plugin - Metadata Module\n该插件通过 Webpack 内置的 BannerPlugin 在编译后的文件头部注入元数据。\n元数据会注入到 window.sentryModuleMetadata 对象下，[key] 为当前文件的 URL (new window.Error().stack)，[value] 为元数据值。\n\nmoduleMetadataIntegration\n通过 beforeEnvelope 生命周期拦截发送到 Sentry 的数据包，从事件的堆栈帧（stack frames）中剥离元数据（metadata），确保数据仅在客户端处理，不会发送到 Sentry 服务器，减少传输的数据量并保护隐私。\n通过 applyFrameMetadata 生命周期，将元数据注入到当前事件中。\n\n多路传输 makeMultiplexedTransport\nbeforeSend 增加解析元数据逻辑，并注入到事件中。\n注册多路传输 transport，根据解析出的元数据分发请求。\n\n其他\n元数据中必须的参数 dsn 和 release\ndsn：用于请求发送到指定仓库。\nrelease：用于版本匹配映射到具体的 source map。\n使用 DefinePlugin 将打包的镜像版本设置为全局变量：123new webpack.DefinePlugin(&#123;  &#x27;process.env.RELEASE_TAG&#x27;: JSON.stringify(release)&#125;)\n\n\n\n\n\n","slug":"2024-12-13","date":"2024-12-12T16:00:00.000Z","categories_index":"Technology","tags_index":"Micro-FE,Sentry,Frontend","author_index":"Charles"},{"id":"d81abd1fab3fac8213cc029b31d1d3c6","title":"解决 node-canvas 安装问题：Mac M1、Python 版本、musl 兼容性","content":"背景在项目中需要生成二维码，因此选择了 easyqrcodejs 作为前端和后端（Node.js）二维码生成方案。然而，在服务端使用 easyqrcodejs 时，依赖的 node-canvas 安装过程中遇到了一些问题。本文记录并提供相应的解决方案。\n\n遇到的问题及解决方案1. Mac M1 芯片无法安装 node-canvasMac M1 电脑缺少 node-canvas 运行所需的依赖库。可以通过以下命令安装必要的依赖：\n1brew install pkg-config cairo pango libpng jpeg giflib librsvg\n\n\n\n\n\n\n\n\n\n\n相关 Issue：Can’t install on Apple M1\n\n2. Python 版本过高导致 import gyp 报错报错信息片段：123Traceback (most recent call last):File &quot;/Users/w/.nvm/versions/node/v18.20.4/lib/node_modules/pnpm/dist/node_modules/node-gyp/gyp/gyp_main.py&quot;, line 42, in ‹module:import gyp\n\n解决方案：该问题通常由 Python 版本过高导致，可使用 Python 3.9.6 解决：\n12pyenv install 3.9.6pyenv global 3.9.6\n\n\n3. node-canvas 安装时报错：Not Found on XXXX报错信息：1node-pre-gyp ERR! install response status 404 Not Found on https://github.com/Automattic/node-canvas/releases/download/v2.11.2/canvas-v2.11.2-node-v108-linux-musl-x64.tar.gz\n\n问题分析：错误发生在 Linux 服务器上，其中 musl 代表 Linux 操作系统使用的 C 标准库，而 node-canvas 仅支持 glibc，不兼容 musl 版本的系统。因此，如果使用 Docker 镜像进行构建，需要确保镜像基于 glibc。\n解决方案：如果在 Alpine Linux（默认使用 musl）上安装 node-canvas，可以切换到 glibc 版本的 Linux 发行版，或者使用 glibc 兼容的 node-canvas 版本。\n12# 使用带 glibc 的 Node.js 镜像docker pull node:lts-bullseye\n\n\n4. 替换国内镜像源以加速安装由于 node-canvas 需要从 github 下载二进制文件，国内访问较慢或受限，可使用淘宝 npm 镜像源进行加速。\n配置 .npmrc 文件：1canvas_binary_host_mirror=https://registry.npmmirror.com/-/binary/canvas/\n\n直接使用 npm 安装：1npm i --canvas_binary_host_mirror=https://registry.npmmirror.com/-/binary/canvas/\n\n使用 pnpm 安装：1pnpm install --config.canvas_binary_host_mirror=https://registry.npmmirror.com/-/binary/canvas/\n\n\n结论在使用 node-canvas 进行二维码生成时，可能会遇到多个环境相关的问题。本文提供了解决 Mac M1、Python 版本、musl 兼容性以及安装加速等方法，希望能帮助遇到相同问题的开发者。\n","slug":"2024-11-26","date":"2024-11-25T16:00:00.000Z","categories_index":"技术","tags_index":"node-canvas,EasyQRCodeJS,Node.js,M1,Docker","author_index":"Charles"},{"id":"1624086166b29c0173181762fde3aaec","title":"深入了解 qiankun 微前端架构","content":"前言随着前端应用的复杂度不断提升，传统的单体应用架构逐渐暴露出维护困难、技术栈升级困难等问题。为了解决这些挑战，微前端架构应运而生。qiankun 作为一款基于 single-spa 的微前端实现库，提供了高效、灵活的解决方案，帮助开发者构建可维护、可扩展的前端系统。\n什么是微前端？微前端是一种将大型前端应用拆分成多个小型、独立、自治的子应用的架构模式。每个子应用可以使用不同的技术栈，独立开发、独立部署，最终通过主应用进行统一管理和展示。微前端的核心思想是“拆”和“合”，即将复杂的应用拆解成多个小模块，再通过主应用将其组合成一个完整的系统。\nQiankun 的优势Qiankun 作为微前端的实现库，具有以下优势：\n\n技术栈无关：主应用和子应用可以使用不同的技术栈，互不干扰。\n独立开发与部署：每个子应用可以独立开发、独立部署，提升开发效率。\n增量升级：可以逐步将老旧系统迁移到微前端架构，实现平滑过渡。\n运行时隔离：子应用之间相互隔离，避免相互影响。\n\nQiankun 的工作原理Qiankun 通过以下方式实现微前端架构：\n\n主应用注册子应用：主应用通过 Qiankun 提供的 API 注册各个子应用，指定子应用的加载方式、路由规则等。\n子应用加载：当路由匹配到某个子应用时，Qiankun 会加载对应的子应用，并将其挂载到指定的 DOM 节点上。\n生命周期管理：Qiankun 为每个子应用提供了生命周期钩子函数，如 bootstrap、mount、unmount，开发者可以在这些钩子中编写相应的逻辑。\n\n实践案例为了更好地理解 qiankun 的使用，以下是一个简单的示例，展示了如何使用 qiankun 实现微前端架构。\n架构示意图12345678910111213141516+-------------------+|   主应用 (Angular)   ||                   ||  +-------------+  ||  | 子应用 1    |  ||  | (Angular)  |  ||  +-------------+  ||  +-------------+  ||  | 子应用 2    |  ||  | (Vue)      |  ||  +-------------+  ||  +-------------+  ||  | 子应用 3    |  ||  | (React)    |  ||  +-------------+  |+-------------------+\n\n\n实现步骤1. 创建主应用 (Angular)首先，在 Angular 项目中安装 qiankun\n1npm install qiankun\n\n然后，在主应用中设置 qiankun 来加载子应用：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import &#123; Component, OnInit &#125; from &#x27;@angular/core&#x27;;import &#123; registerMicroApps, setDefaultMountApp, start &#125; from &#x27;qiankun&#x27;;@Component(&#123;  selector: &#x27;#parent-angular app-root&#x27;,  templateUrl: &#x27;./app.component.html&#x27;,  styleUrls: [&#x27;./app.component.scss&#x27;]&#125;)export class AppComponent implements OnInit &#123;  ngOnInit() : void &#123;    this.registerMicroApps();  &#125;  registerMicroApps() : void &#123;    registerMicroApps([      &#123;        name: &#x27;child-react&#x27;,        entry: &#x27;//localhost:3000&#x27;,        container: &#x27;#subapp-viewer&#x27;,        activeRule: location =&gt; location.hash.startsWith(&#x27;#/sub-micro/child-react&#x27;)      &#125;,      &#123;        name: &#x27;child-vue&#x27;,        entry: &#x27;//localhost:8080&#x27;,        container: &#x27;#subapp-viewer&#x27;,        activeRule: location =&gt; location.hash.startsWith(&#x27;#/sub-micro/child-vue&#x27;)      &#125;,      &#123;        name: &#x27;child-angular&#x27;,        entry: &#x27;//localhost:4300&#x27;,        container: &#x27;#subapp-viewer&#x27;,        activeRule: location =&gt; location.hash.startsWith(&#x27;#/sub-micro/child-angular&#x27;)      &#125;    ],    &#123;      beforeLoad: [        app =&gt; &#123;          console.log(&#x27;[LifeCycle] before load %c%s&#x27;, &#x27;color: green;&#x27;, app.name);          return Promise.resolve();        &#125;,      ],      beforeMount: [        app =&gt; &#123;          console.log(&#x27;[LifeCycle] before mount %c%s&#x27;, &#x27;color: green;&#x27;, app.name);          return Promise.resolve();        &#125;,      ],      afterUnmount: [        app =&gt; &#123;          console.log(&#x27;[LifeCycle] after unmount %c%s&#x27;, &#x27;color: green;&#x27;, app.name);          return Promise.resolve();        &#125;,      ],    &#125;    )  &#125;&#125;\n在子项目路由根组件中调用start方法加载qiankun\n123456789101112131415161718192021222324import &#123; AfterViewInit, Component, OnInit &#125; from &#x27;@angular/core&#x27;;import &#123; registerMicroApps, start &#125; from &#x27;qiankun&#x27;;@Component(&#123;  selector: &#x27;app-sub-micro&#x27;,  templateUrl: &#x27;./sub-micro.component.html&#x27;,  styleUrls: [&#x27;./sub-micro.component.scss&#x27;]&#125;)export class SubMicroComponent implements OnInit, AfterViewInit&#123;  constructor() &#123; &#125;  ngAfterViewInit(): void &#123;    start(      &#123;        prefetch: false // 取消预加载      &#125;    );  &#125;  ngOnInit(): void &#123;  &#125;&#125;\n2. 创建子应用 (Angular)使用 Angular 创建一个子应用，并确保它能够独立运行。确保在构建时，将子应用暴露为一个微前端应用，供主应用加载。通过window.__POWERED_BY_QIANKUN__标识判断当前应用是否是通过 qiankun 加载的微前端子应用。如果该值为 true，说明当前应用是一个微前端子应用；如果为 false，说明应用是独立运行的\n12345678910111213141516171819202122import &#123; APP_BASE_HREF &#125; from &#x27;@angular/common&#x27;;import &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; RouterModule, Routes &#125; from &#x27;@angular/router&#x27;;const routes: Routes = [  &#123;    path: &#x27;&#x27;,    loadChildren: () =&gt; import(&#x27;./home/home.module&#x27;).then(m =&gt; m.HomeModule)  &#125;,  &#123;    path: &#x27;readme&#x27;,    loadChildren: () =&gt; import(&#x27;./readme/readme.module&#x27;).then(m =&gt; m.ReadmeModule)  &#125;];@NgModule(&#123;  imports: [RouterModule.forRoot(routes)],  exports: [RouterModule],  // @ts-ignore  providers: [&#123;provide: APP_BASE_HREF, useValue: window.__POWERED_BY_QIANKUN__ ? &#x27;/sub-micro/child-angular&#x27; : &#x27;/&#x27;&#125;]&#125;)export class AppRoutingModule &#123; &#125;\n\n3. 创建子应用 (Vue)使用 Vue 创建一个子应用，并确保它能够独立运行。确保在构建时，将子应用暴露为一个微前端应用，供主应用加载。通过window.__POWERED_BY_QIANKUN__标识判断当前应用是否是通过 qiankun 加载的微前端子应用。如果该值为 true，说明当前应用是一个微前端子应用；如果为 false，说明应用是独立运行的\n12345678910111213141516171819202122232425262728import Vue from &#x27;vue&#x27;;import VueRouter, &#123; RouteConfig &#125; from &#x27;vue-router&#x27;;import Home from &#x27;../views/Home.vue&#x27;;declare const window: any;Vue.use(VueRouter);const routes: RouteConfig[] = [  &#123;    path: &#x27;/sub-micro/child-vue/&#x27;,    name: &#x27;Home&#x27;,    component: Home,  &#125;,  &#123;    path: &#x27;/sub-micro/child-vue/about&#x27;,    name: &#x27;About&#x27;,    // route level code-splitting    // this generates a separate chunk (about.[hash].js) for this route    // which is lazy-loaded when the route is visited.    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;),  &#125;,];const router = new VueRouter(&#123;  base: window.__POWERED_BY_QIANKUN__ ? &#x27;/sub-micro/child-vue&#x27; : &#x27;/sub-micro/child-vue&#x27;,  mode: &#x27;hash&#x27;,  routes,&#125;);export default router;\n\n4. 创建子应用 (React)使用 React 创建一个子应用，并确保它能够独立运行。确保在构建时，将子应用暴露为一个微前端应用，供主应用加载。通过window.__POWERED_BY_QIANKUN__标识判断当前应用是否是通过 qiankun 加载的微前端子应用。如果该值为 true，说明当前应用是一个微前端子应用；如果为 false，说明应用是独立运行的\n1234567891011121314151617181920212223242526272829303132333435363738import &#x27;./public-path&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123; BrowserRouter,HashRouter,Route,Switch &#125; from &quot;react-router-dom&quot;;import &#x27;./index.css&#x27;;import Home from &#x27;./home&#x27;;import Readme from &#x27;./readme/readme&#x27;;function render(props) &#123;  const &#123; container &#125; = props;  ReactDOM.render(    &lt;React.StrictMode&gt;      &lt;HashRouter basename=&#123;window.__POWERED_BY_QIANKUN__ ? &#x27;/sub-micro/child-react&#x27; : &#x27;/&#x27;&#125;&gt;        &lt;Switch&gt;            &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt;            &lt;Route exact path=&quot;/readme&quot; component=&#123;Readme&#125; /&gt;        &lt;/Switch&gt;      &lt;/HashRouter&gt;    &lt;/React.StrictMode&gt;, container ? container.querySelector(&#x27;#root&#x27;) : document.querySelector(&#x27;#root&#x27;)  );&#125;if(!window.__POWERED_BY_QIANKUN__) &#123;  render(&#123;&#125;);&#125;export async function bootstrap()&#123;&#125;export async function mount(props) &#123;  render(props);&#125;export async function unmount(props) &#123;  const &#123; container &#125; = props;  ReactDOM.unmountComponentAtNode(container ? container.querySelector(&#x27;#root&#x27;) : document.querySelector(&#x27;#root&#x27;));&#125;\n\n运行和部署在完成以上步骤后，可以启动各个子应用和主应用，确保它们都能独立运行，并通过 qiankun 框架将它们集成在一起。\n子应用的运行地址分别是：\n\nAngular 子应用：http://localhost:3000\nVue 子应用：http://localhost:8000\nReact 子应用：http://localhost:4300\n\nDemo 代码为了帮助您更好地理解整个过程，我已经将所有代码整合并发布到了 GitHub。您可以访问 qiankun-demo 查看完整的代码实现，并根据自己的需求进行修改。\n","slug":"2021-07-26","date":"2021-07-25T16:00:00.000Z","categories_index":"技术","tags_index":"qiankun,微前端,前端架构","author_index":"Charles"},{"id":"8106ab3111152a5d4804fa67308308c0","title":"解决IE8连接TLS 1.0服务端的问题","content":"问题描述在某些情况下，IE8客户端无法连接到支持TLS 1.0协议的服务端。这表明客户端请求的Cipher Suite在服务端不被支持。问题原因是服务端的JDK&#x2F;JRE默认不支持IE8所需的Cipher Suite。\nIE8支持的Cipher Suite以下是IE8在TLS1.0协议下支持的Cipher Suite列表：\n\nCipher Suite: TLS_RSA_WITH_AES_256_CBC_SHA (0x0035)\nCipher Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA (0x000a)\nCipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA (0x002f)\nCipher Suite: TLS_RSA_WITH_RC4_128_SHA (0x0005)\nCipher Suite: TLS_RSA_WITH_RC4_128_MD5 (0x0004)\nCipher Suite: TLS_RSA_WITH_DES_CBC_SHA (0x0009)\n\n问题分析当前装的JDK&#x2F;JRE版本并不包含这些Cipher Suite，因此导致IE8无法连接到服务端。\n解决方法1. 下载并安装Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files为了解决Cipher Suite不兼容的问题，我们需要下载并安装Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files。\n\n下载地址：JCE Unlimited Strength Jurisdiction Policy Files 8\n安装后，需要替换掉JRE的lib/security目录下的两个jar文件。\n\n2. 配置服务端支持更多Cipher Suites安装JCE后，我们需要在Spring Boot的配置文件中指定支持的Cipher Suites。以下是一个包含常见Cipher Suites的配置，可以将其加入到application.yml文件中：\nyamlserver:\n  ssl:\n    ciphers: TLS_ECDH_anon_WITH_RC4_128_SHA, TLS_ECDH_ECDSA_WITH_RC4_128_SHA, \n            TLS_ECDH_RSA_WITH_RC4_128_SHA, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n            TLS_KRB5_EXPORT_WITH_RC4_40_MD5, TLS_KRB5_EXPORT_WITH_RC4_40_SHA\n            TLS_KRB5_WITH_RC4_128_MD5, TLS_KRB5_WITH_RC4_128_SHA\n            TLS_DH_anon_WITH_AES_128_GCM_SHA256, TLS_DH_anon_WITH_AES_256_GCM_SHA384\n            TLS_DHE_DSS_WITH_AES_128_GCM_SHA256, TLS_DHE_DSS_WITH_AES_256_GCM_SHA384\n            TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384\n            TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384\n            TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n            TLS_RSA_WITH_RC4_128_MD5, TLS_RSA_WITH_RC4_128_SHA\n            TLS_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA\n            TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n            TLS_RSA_WITH","slug":"2020-03-27","date":"2020-03-26T16:00:00.000Z","categories_index":"技术","tags_index":"TLS,Cipher Suite,JDK,JRE","author_index":"Charles"}]